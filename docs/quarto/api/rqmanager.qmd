---
title: "RQManager"
---

# RQManager

**Module:** `flowerpower.job_queue.rq.RQManager`

The `RQManager` is the implementation of `JobQueueManager` for Redis Queue (RQ). It handles the specifics of interacting with an RQ backend.

## Initialization

### __init__
```python
__init__(self, name: str, base_dir: str | None = None, backend: RQBackend | None = None, storage_options: dict | None = None, fs: AbstractFileSystem | None = None, log_level: str | None = None)
```

Initializes the `RQManager`.

| Parameter | Type | Description | Default |
|:----------|:-----|:------------|:--------|
| `name` | `str` | The name of the scheduler instance. | |
| `base_dir` | `str \| None` | The base directory of the project. | `None` |
| `backend` | `RQBackend \| None` | An `RQBackend` instance for Redis connection configuration. | `None` |
| `storage_options` | `dict \| None` | Storage options for the filesystem. | `None` |
| `fs` | `AbstractFileSystem \| None` | An fsspec-compatible filesystem instance. | `None` |
| `log_level` | `str \| None` | The logging level. | `None` |

## Methods

### enqueue
```python
enqueue(self, func: Callable, *args, **kwargs)
```

Enqueues a job for immediate, delayed, or scheduled execution.

This is the main method for adding jobs to the queue. It supports:
- Immediate execution (no `run_at` or `run_in` parameters)
- Delayed execution (`run_in` parameter)
- Scheduled execution (`run_at` parameter)

| Parameter | Type | Description |
|:----------|:-----|:------------|
| `func` | `Callable` | The function to execute. Must be importable from the worker process. |
| `*args` | `Any` | Positional arguments for the function. |
| `**kwargs` | `Any` | Keyword arguments including: |
|           |      | - `run_in`: Schedule the job to run after a delay (`timedelta`, `int` seconds, or `str`) |
|           |      | - `run_at`: Schedule the job to run at a specific `datetime` |
|           |      | - Other job queue specific parameters (`timeout`, `retry`, etc.) |

**Returns:** `Job` - The created job instance.

**Raises:** `ValueError`: If the function is not serializable or arguments are invalid.

#### Example

```python
from flowerpower.job_queue.rq import RQManager
from datetime import datetime, timedelta

manager = RQManager(name="my_rq_manager")

def my_task(x, y):
    return x + y

# Immediate execution
job = manager.enqueue(my_task, 1, 2, job_id="my_sum_job")
print(f"Enqueued job: {job.id}")

# Delayed execution (5 minutes)
job = manager.enqueue(my_task, 3, 4, run_in=timedelta(minutes=5))

# Scheduled execution (specific time)
target_time = datetime(2025, 1, 1, 10, 0, 0)
job = manager.enqueue(my_task, 5, 6, run_at=target_time)
```

### enqueue_in
```python
enqueue_in(self, delay: timedelta | int | str, func: Callable, *args, **kwargs)
```

Enqueues a job to run after a specified delay.

This is a convenience method for delayed execution. It's equivalent to
calling `enqueue()` with the `run_in` parameter.

| Parameter | Type | Description |
|:----------|:-----|:------------|
| `delay` | `timedelta | int | str` | The delay before execution. Can be a `timedelta` object, an integer (seconds), or a string (e.g., "1m" for 1 minute). |
| `func` | `Callable` | The function to execute. |
| `*args` | `Any` | Positional arguments for the function. |
| `**kwargs` | `Any` | Keyword arguments for the function and job options. |

**Returns:** `Job` - The created job instance.

**Raises:** `ValueError`: If `delay` is invalid or `func` is not callable.

#### Example

```python
from flowerpower.job_queue.rq import RQManager
from datetime import timedelta

manager = RQManager(name="my_rq_manager")

def send_notification(message):
    print(f"Notification: {message}")

# Enqueue a job to run in 5 minutes
job = manager.enqueue_in(timedelta(minutes=5), send_notification, "Your report is ready!")

# Enqueue a job to run in 30 seconds (integer delay)
job = manager.enqueue_in(30, send_notification, "Quick update!")

# Enqueue a job to run in 1 hour (string delay)
job = manager.enqueue_in("1h", send_notification, "Hourly reminder!")
```

### enqueue_at
```python
enqueue_at(self, datetime_obj: datetime, func: Callable, *args, **kwargs)
```

Enqueues a job to run at a specific datetime.

This is a convenience method for scheduled execution. It's equivalent to
calling `enqueue()` with the `run_at` parameter.

| Parameter | Type | Description |
|:----------|:-----|:------------|
| `datetime_obj` | `datetime` | The datetime to execute the job. |
| `func` | `Callable` | The function to execute. |
| `*args` | `Any` | Positional arguments for the function. |
| `**kwargs` | `Any` | Keyword arguments for the function and job. |

**Returns:** `Job` - The created job instance.

**Raises:** `ValueError`: If `datetime_obj` is in the past or `func` is not callable.

#### Example

```python
from flowerpower.job_queue.rq import RQManager
from datetime import datetime

manager = RQManager(name="my_rq_manager")

def generate_monthly_report(month, year):
    print(f"Generating report for {month}/{year}")

# Enqueue a job to run at a specific future date and time
target_time = datetime(2025, 1, 1, 9, 0, 0)
job = manager.enqueue_at(target_time, generate_monthly_report, 1, 2025)
```

### start_worker
```python
start_worker(self, background: bool = False, queue_names: list[str] | None = None, with_scheduler: bool = False, num_workers: int | None = None, **kwargs)
```

Starts a worker process for the job queue.

| Parameter | Type | Description | Default |
|:----------|:-----|:------------|:--------|
| `background` | `bool` | If `True`, runs the worker in the background. | `False` |
| `queue_names` | `list[str] \| None` | A list of RQ queues to listen to. Defaults to all queues. | `None` |
| `with_scheduler` | `bool` | If `True`, the worker also processes scheduled jobs. | `False` |
| `num_workers` | `int | None` | Number of worker processes to start (pool mode). | `None` |
| `**kwargs` | `Any` | Additional arguments for RQ's `Worker` class. | |

**Returns:** `None`

**Raises:** `RuntimeError`: If the worker fails to start.

#### Example

```python
from flowerpower.job_queue.rq import RQManager

manager = RQManager(name="my_rq_manager")

# Start a worker in the foreground, listening to the 'default' queue
manager.start_worker(queue_names=["default"])

# Start a worker in the background with scheduler enabled
manager.start_worker(background=True, with_scheduler=True)

# Start a worker pool with 4 processes
manager.start_worker(num_workers=4)
```