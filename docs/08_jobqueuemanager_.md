# Chapter 8: The Task Dispatcher – JobQueueManager

In modern data workflows, running pipelines asynchronously or on a schedule is essential for scalability and automation. `JobQueueManager` is the core abstraction in `flowerpower` for handling asynchronous job submission and scheduling.

---

## What is `JobQueueManager`?

`JobQueueManager` is the **base class** responsible for interfacing with various backend systems that support background job execution and scheduling (such as RQ, APScheduler, etc.). It acts as a factory and manager for these backends, allowing the project to submit jobs or schedule them for later execution.

- **Backend Agnostic:** The actual backend (e.g., RQ, APScheduler) is selected based on your project configuration (`job_queue.type` in `conf/project.yml`).
- **Unified Interface:** Provides a consistent API for job submission and scheduling, regardless of the backend.

---

## Important: Do Not Use `JobQueueManager` Directly

**You should _not_ call methods on `JobQueueManager` directly.**  
All job submission and scheduling should be performed via the main [`FlowerPowerProject`](../src/flowerpower/flowerpower.py) object (or its high-level API), which exposes the correct methods and ensures proper context and configuration.

### How to Submit and Schedule Jobs

Use the `add_job` and `schedule` methods on your main project object.  
**Do not instantiate or interact with `JobQueueManager` yourself.**

#### Example: Submitting a Pipeline as a Background Job

```python
from flowerpower import FlowerPowerProject

project = FlowerPowerProject()
job_info = project.add_job(
    name="data_cleansing",
    inputs={"source_file": "large_dataset.parquet"}
)
print(f"Job added! ID: {job_info.id}")
```

#### Example: Scheduling a Pipeline

```python
from flowerpower import FlowerPowerProject

project = FlowerPowerProject()
schedule_id = project.schedule(
    name="daily_report",
    cron="0 8 * * 1-5"  # 8:00 AM, Monday–Friday
)
print(f"Pipeline scheduled! Schedule ID: {schedule_id}")
```

These methods handle all necessary delegation and context setup.  
**Direct use of `JobQueueManager` is reserved for advanced backend integrations and should not be needed in typical usage.**

---

## How It Works

- The main project object (`FlowerPowerProject`) manages all pipeline and job operations.
- When you call `add_job` or `schedule`, the project object delegates to the appropriate backend via `JobQueueManager`.
- The backend is chosen according to your configuration, and all job lifecycle management is handled automatically.

---

## Migrating from Previous Versions

If you previously used `PipelineJobQueue` or called job queue methods on lower-level classes, update your code to use only the high-level project API (`add_job`, `schedule` on `FlowerPowerProject`).  
All direct references to `PipelineJobQueue` are now obsolete.

---

## Summary

- **`JobQueueManager`** is the base for async job submission and scheduling.
- **Do not use it directly**—always use the main project object's API.
- **Use `add_job` and `schedule`** on `FlowerPowerProject` for all job-related operations.
- The backend system is selected and managed automatically.

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)